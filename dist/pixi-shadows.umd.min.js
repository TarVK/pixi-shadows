/* eslint-disable */
this.PIXI=this.PIXI||{},this.PIXI.shadows=this.PIXI.shadows||{},function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("@pixi/layers"),require("@pixi/display"),require("@pixi/constants"),require("@pixi/core"),require("@pixi/math"),require("@pixi/sprite"),require("@pixi/ticker")):"function"==typeof define&&define.amd?define(["exports","@pixi/layers","@pixi/display","@pixi/constants","@pixi/core","@pixi/math","@pixi/sprite","@pixi/ticker"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).pixi_shadows={},t.PIXI.display,t.PIXI,t.PIXI,t.PIXI,t.PIXI,t.PIXI)}(this,(function(t,e,i,n,s,r,a){"use strict";const o="\nfloat colorToFloat(vec4 color){\n    return (color.r + (color.g + color.b * 256.0) * 256.0) * 255.0 - 8388608.0;\n}\nvec4 floatToColor(float f){\n    f += 8388608.0;\n    vec4 color;\n    color.a = 255.0;\n    color.b = floor(f / 256.0 / 256.0);\n    color.g = floor((f - color.b * 256.0 * 256.0) / 256.0);\n    color.r = floor(f - color.b * 256.0 * 256.0 - color.g * 256.0);\n    return color / 255.0;\n}\n";class h extends s.Filter{__init(){this.autoFit=!1}__init2(){this.padding=0}__init3(){this.ignoreShadowCasterMatrix=new r.Matrix}constructor(t){super("\n            attribute vec2 aVertexPosition;\n            attribute vec2 aTextureCoord;\n            \n            uniform mat3 projectionMatrix;\n            uniform mat3 filterMatrix;\n            \n            varying vec2 vTextureCoord;\n            varying vec2 vFilterCoord;\n            \n            void main(void){\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n                vTextureCoord = aTextureCoord;\n            }\n        ",`\n            varying vec2 vMaskCoord;\n            varying vec2 vTextureCoord;\n            uniform vec4 filterArea;\n            \n            uniform sampler2D shadowCasterSampler;\n            uniform vec2 shadowCasterSpriteDimensions;\n\n            uniform bool hasIgnoreShadowCaster;\n            uniform sampler2D ignoreShadowCasterSampler;\n            uniform mat3 ignoreShadowCasterMatrix;\n            uniform vec2 ignoreShadowCasterDimensions;\n\n            uniform float lightRange;\n            uniform float lightScatterRange;\n            uniform vec2 lightLoc;\n\n            uniform float depthResolution;\n            uniform bool darkenOverlay;\n\n            uniform vec2 dimensions;\n\n            ${o}\n            \n            void main(void){\n                float pi = 3.141592653589793238462643;\n                \n                // Cap the depthResolution (as I expect performance loss by having a big value, but I am not sure)\n                float depthRes = min(2000.0, depthResolution);\n\n                // The current coordinate on the texutre measured in pixels, as well as a fraction\n                vec2 pixelCoord = vTextureCoord * filterArea.xy;\n                vec2 normalizedCoord = pixelCoord / dimensions;\n                \n                // Extract the components of the normalized coordinate\n                float x = normalizedCoord.x;\n                float y = normalizedCoord.y;\n\n                // Calculate the offset of the lightPoint we are currently at\n                float offsetAngle = 2.0 * pi * y;\n                vec2 offset = vec2(cos(offsetAngle), sin(offsetAngle)) * lightScatterRange;\n\n                // Calculate the angle at which we are ray tracing\n                float angle = x * pi * 2.0;\n\n                // The distance at which we hit an object\n                float hitDistancePer = 1.0;\n\n                // Increase the distance until we hit an object or reach the maximum value\n                bool reached = false;\n                for(float dist=0.0; dist < 2000.0; dist+=1.0){\n                    if(dist > depthRes) break;\n                    \n                    // Calculate the actual distance in pixel units, and use it to calculate the pixel coordinate to inspect\n                    float distance = dist / depthRes * lightRange;\n                    vec2 coord = lightLoc + offset + vec2(cos(angle), sin(angle)) * distance;\n                \n                    // Extract the pixel and check if it is opaque\n                    float opacity = texture2D(shadowCasterSampler, coord / shadowCasterSpriteDimensions).a;\n                    if((opacity > 0.0 && darkenOverlay) || opacity > 0.5){\n                        // Check if it isn't hitting something that should be ignore\n                        if(hasIgnoreShadowCaster){ \n                            vec2 l = (ignoreShadowCasterMatrix * vec3(coord, 1.0)).xy / ignoreShadowCasterDimensions;\n                            if(l.x >= -0.01 && l.x <= 1.01 && l.y >= -0.01 && l.y <= 1.01){\n                                // If the pixel at the ignoreShadowCaster is opaque here, skip this pixel\n                                if(opacity > 0.0){\n                                    continue;\n                                }\n                            }\n                        }\n\n                        // Calculate the percentage at which this hit occurred, and stop the loop\n                        if(!darkenOverlay){\n                            hitDistancePer = distance / lightRange;\n                            break;\n                        }\n                        reached = true;\n                    }else if(reached){\n                        hitDistancePer = (distance - 1.0) / lightRange;\n                        break;\n                    }\n                }\n\n                // Express the distance as a color in the map\n                gl_FragColor = floatToColor(hitDistancePer * 100000.0);\n            }\n        `),this.shadow=t,h.prototype.__init.call(this),h.prototype.__init2.call(this),h.prototype.__init3.call(this),this.uniforms.lightPointCount=t.pointCount,this.uniforms.dimensions=[t.radialResolution,t.pointCount]}apply(t,e,i,n){this.uniforms.darkenOverlay=this.shadow.darkenOverlay;const s=this.shadow._shadowCasterSprite;this.uniforms.shadowCasterSpriteDimensions=[s.width,s.height],this.uniforms.shadowCasterSampler=s._texture;const r=this.shadow.worldTransform,a=Math.sqrt(r.a*r.a+r.b*r.b),o=this.shadow.range*a;this.uniforms.lightRange=o,this.uniforms.lightScatterRange=this.shadow.scatterRange,this.uniforms.lightLoc=[r.tx,r.ty],this.uniforms.depthResolution=o*this.shadow.depthResolution;const h=this.shadow.ignoreShadowCaster;this.uniforms.hasIgnoreShadowCaster=!!h,h&&(h.worldTransform.copyFrom(this.ignoreShadowCasterMatrix),this.uniforms.ignoreShadowCasterMatrix=this.ignoreShadowCasterMatrix.invert(),this.uniforms.ignoreShadowCasterDimensions=[h.width,h.height],this.uniforms.ignoreShadowCasterSampler=h._texture),t.applyFilter(this,e,i,n)}}class l extends s.Filter{__init(){this.inverted=!1}__init2(){this.autoFit=!1}__init3(){this.padding=0}__init4(){this.overlayMatrix=new r.Matrix}constructor(t){super("\n            attribute vec2 aVertexPosition;\n            attribute vec2 aTextureCoord;\n            \n            uniform mat3 projectionMatrix;\n            uniform mat3 overlayMatrix;\n            uniform mat3 filterMatrix;\n            \n            varying vec2 vTextureCoord;\n            varying vec2 vOverlayCoord;\n            varying vec2 vFilterCoord;\n            \n            void main(void){\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n                vTextureCoord = aTextureCoord;\n                vOverlayCoord = (overlayMatrix * vec3(aTextureCoord, 1.0) ).xy;\n            }\n        ",`\n            varying vec2 vOverlayCoord;\n            varying vec2 vTextureCoord;\n            uniform vec4 filterArea;\n            \n            uniform sampler2D shadowOverlaySampler;\n\n            uniform vec2 dimensions;\n\n            uniform sampler2D shadowSampler;\n\n            uniform bool darkenOverlay;\n            uniform bool inverted;\n\n            uniform float overlayLightLength;\n\n            uniform float lightPointCount;\n            uniform float lightRange;\n            uniform float lightScatterRange;\n            uniform float lightIntensity;\n            uniform float fallOffFraction;\n\n            ${o}\n            \n            void main(void){\n                float pi = 3.141592653589793238462643;\n                \n                // The current coordinate on the texture measured in pixels\n                vec2 pixelCoord = vTextureCoord * filterArea.xy;\n\n                // The distance delta relative to the center\n                vec2 lightDelta = pixelCoord - dimensions / 2.0;\n                float distance = sqrt(lightDelta.x * lightDelta.x + lightDelta.y * lightDelta.y);\n                if (distance > lightRange) return;\n\n                // The final intensity of the light at this pixel\n                float totalIntensity = 0.0;\n\n                // The intensity of the pixel in the overlay map at this pixel\n                vec4 overlayPixel = texture2D(shadowOverlaySampler, vOverlayCoord);\n\n                // Go through all light points (at most 1000) to add them to the intensity\n                for(float lightIndex=0.0; lightIndex<1000.0; lightIndex++){\n                    if (lightIndex >= lightPointCount) break; // Stop the loop if we went over the pointCount\n\n                    // Calculate the offset of this lightPoint, relative the the center of the light\n                    float lightIndexFrac = (lightIndex + 0.5) / lightPointCount;\n                    float offsetAngle = 2.0 * pi * lightIndexFrac;\n                    vec2 offset = vec2(cos(offsetAngle), sin(offsetAngle)) * lightScatterRange;\n\n                    // Calculate the location of this pixel relative to the lightPoint, and check the depth map\n                    vec2 pointDelta = lightDelta - offset;\n                    float pointDistance = sqrt(pointDelta.x * pointDelta.x + pointDelta.y * pointDelta.y);\n                    float angle = mod(atan(pointDelta.y, pointDelta.x) + 2.0 * pi, 2.0 * pi);\n                    vec4 depthPixel = texture2D(shadowSampler, vec2(angle / (2.0 * pi), lightIndexFrac));\n\n                    // Extract the object distance from the depth map pixel\n                    float objectDistance = colorToFloat(depthPixel) / 100000.0 * lightRange;\n                    \n                    // Calculate the intensity of this pixel based on the overlaySampler and objectDistance\n                    float distFromEdge = lightRange - distance;\n                    float fallOffDist = lightRange * fallOffFraction;\n                    float defaultIntensity = min(1.0, distFromEdge/fallOffDist);\n\n\n                    float intensity = 0.0;\n                    if (darkenOverlay) {\n                        if (objectDistance > pointDistance || objectDistance >= lightRange) {\n                            intensity = defaultIntensity;\n                        }else if (overlayPixel.a > 0.5) {\n                            intensity = defaultIntensity * pow(1.0 - (distance - objectDistance) / (lightRange - objectDistance), 2.5) * overlayPixel.a;\n                        }\n                    } else {\n                        if (inverted) {\n                            if (overlayPixel.a > 0.5) {\n                                intensity = 1.0-overlayPixel.a;\n                            }else if (objectDistance > pointDistance || objectDistance >= lightRange) {\n                                intensity = 0.0;\n                            }else{\n                                intensity = 1.0;\n                            }\n                        }else{\n                            if (objectDistance > pointDistance || objectDistance >= lightRange) {\n                                intensity = defaultIntensity;\n                            }else if (overlayPixel.a > 0.5) {\n                                intensity = defaultIntensity * (1.0 - (pointDistance - objectDistance) / overlayLightLength);\n                            }\n                        }\n                    }\n                    \n\n                    // Add the intensity to the total intensity\n                    totalIntensity += intensity / lightPointCount;\n                }\n\n                // Create a mask based on the intensity\n                gl_FragColor = vec4(vec3(lightIntensity * totalIntensity), 1.0);\n            }\n        `),this.shadow=t,l.prototype.__init.call(this),l.prototype.__init2.call(this),l.prototype.__init3.call(this),l.prototype.__init4.call(this),this.uniforms.shadowSampler=t._shadowMapResultTexture,this.uniforms.lightPointCount=t.pointCount}apply(t,e,i,n){this.uniforms.fallOffFraction=this.shadow.fallOffFraction,this.uniforms.darkenOverlay=this.shadow.darkenOverlay;const s=this.shadow._shadowOverlaySprite;this.uniforms.shadowOverlaySpriteDimensions=[s.width,s.height],this.uniforms.shadowOverlaySampler=s._texture;const r=this.shadow.worldTransform,a=Math.sqrt(r.a*r.a+r.b*r.b),o=this.shadow.range*a;this.uniforms.lightRange=o,this.uniforms.lightScatterRange=this.shadow.scatterRange,this.uniforms.lightIntensity=this.shadow.intensity,this.uniforms.overlayLightLength=this.shadow.overlayLightLength,this.uniforms.inverted=this.inverted;const h=2*this.shadow.range*(r.a+r.b);this.uniforms.dimensions=[h,h],this.uniforms.overlayMatrix=t.calculateSpriteMatrix(this.overlayMatrix,s),t.applyFilter(this,e,i,n)}}class d extends a.Sprite{__init(){this.depthResolution=1}__init2(){this.darkenOverlay=!1}__init3(){this.overlayLightLength=1/0}__init4(){this.fallOffFraction=1}constructor(t,e=1,i=20,n=(1===i?0:15),r=800){super(s.RenderTexture.create({width:2*t,height:2*t})),this._range=t,this.intensity=e,this._pointCount=i,this.scatterRange=n,this._radialResolution=r,d.prototype.__init.call(this),d.prototype.__init2.call(this),d.prototype.__init3.call(this),d.prototype.__init4.call(this),this.anchor.set(.5),this.__createShadowMapSources()}__updateTextureSize(){this.texture.destroy(),this.texture=s.RenderTexture.create({width:2*this._range,height:2*this._range})}__createShadowMapSources(){this._shadowMapSprite&&this._shadowMapSprite.destroy(),this.shadowMapResultSprite&&this.shadowMapResultSprite.destroy(),this._shadowMapResultTexture&&this._shadowMapResultTexture.destroy(),this._shadowMapResultTexture=s.RenderTexture.create({width:this._radialResolution,height:this._pointCount}),this._shadowMapResultTexture.baseTexture.scaleMode=n.SCALE_MODES.NEAREST,this._shadowMapSprite=new a.Sprite(this._shadowMapResultTexture),this._shadowMapSprite.filters=[new h(this)],this.shadowMapResultSprite=new a.Sprite(this._shadowMapResultTexture);const t=new l(this);t.blendMode=n.BLEND_MODES.ADD,this.shadowFilter=t,this.filters=[t]}destroy(){return this._shadowMapSprite&&this._shadowMapSprite.destroy(),this.shadowMapResultSprite&&this.shadowMapResultSprite.destroy(),this._shadowMapResultTexture&&this._shadowMapResultTexture.destroy(),this.texture.destroy(),super.destroy()}renderAdvanced(t){this.renderStep&&super.renderAdvanced(t)}update(t,e,i){this._shadowCasterSprite=e,this._shadowOverlaySprite=i,t.render(this._shadowMapSprite,{renderTexture:this._shadowMapResultTexture,clear:!0,skipUpdateTransform:!0})}set range(t){this._range=t,this.__updateTextureSize()}get range(){return this._range}set pointCount(t){this._pointCount=t,this.__createShadowMapSources()}get pointCount(){return this._pointCount}set radialResolution(t){this._radialResolution=t,this.__createShadowMapSources()}get radialResolution(){return this._radialResolution}}class u extends s.Filter{__init(){this.tick=0}__init2(){this._useShadowCastersAsOverlay=!0}constructor(t,e){super("\n            attribute vec2 aVertexPosition;\n            attribute vec2 aTextureCoord;\n            \n            uniform mat3 projectionMatrix;\n            uniform mat3 otherMatrix;\n            \n            varying vec2 vMaskCoord;\n            varying vec2 vTextureCoord;\n            \n            void main(void)\n            {\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n            \n                vTextureCoord = aTextureCoord;\n                vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n            }\n        ","                    \n            varying vec2 vMaskCoord;\n            varying vec2 vTextureCoord;\n            \n            uniform sampler2D uSampler;\n            uniform sampler2D mask;\n            uniform vec4 maskClamp;\n            uniform float ambientLight;\n            \n            void main(void){            \n                vec4 original = texture2D(uSampler, vTextureCoord);\n                vec4 masky = texture2D(mask, vMaskCoord);\n            \n                original *= ambientLight + (1.0 - ambientLight) * (masky.r + masky.g + masky.b) / 3.0;\n            \n                gl_FragColor = original;\n            }\n        "),this._width=t,this._height=e,u.prototype.__init.call(this),u.prototype.__init2.call(this),this.uniforms.ambientLight=0,this.uniforms.size=[this._width,this._height],this.__createCasterSources(),this.__createOverlaySources(),this.__createMaskSources()}__createOverlaySources(){this._shadowOverlayResultTexture&&this._shadowOverlayResultTexture.destroy(),this._shadowOverlayResultSprite&&this._shadowOverlayResultSprite.destroy(),this._shadowOverlayContainer||(this._shadowOverlayContainer=new i.Container),this._shadowOverlayResultTexture=s.RenderTexture.create({width:this._width,height:this._height}),this._shadowOverlayResultTexture.baseTexture.scaleMode=n.SCALE_MODES.NEAREST,this._shadowOverlayResultSprite=new a.Sprite(this._shadowOverlayResultTexture)}__createCasterSources(){this._shadowCasterResultTexture&&this._shadowCasterResultTexture.destroy(),this._shadowCasterResultSprite&&this._shadowCasterResultSprite.destroy(),this._shadowCasterContainer||(this._shadowCasterContainer=new i.Container),this._shadowCasterResultTexture=s.RenderTexture.create({width:this._width,height:this._height}),this._shadowCasterResultTexture.baseTexture.scaleMode=n.SCALE_MODES.NEAREST,this._shadowCasterResultSprite=new a.Sprite(this._shadowCasterResultTexture)}__createMaskSources(){this._maskResultTexture&&this._maskResultTexture.destroy(),this._maskResultSprite&&this._maskResultSprite.destroy(),this._maskMatrix||(this._maskMatrix=new r.Matrix),this._maskResultTexture=s.RenderTexture.create({width:this._width,height:this._height}),this._maskResultTexture.baseTexture.scaleMode=n.SCALE_MODES.NEAREST,this._maskContainer||(this._maskContainer=new i.Container),this._maskResultSprite=new a.Sprite(this._maskResultTexture)}update(t){this.tick++,this._shadowCasterContainer.children.forEach((t=>{t._activeParentLayer=null})),t.render(this._shadowCasterContainer,{renderTexture:this._shadowCasterResultTexture,clear:!0,skipUpdateTransform:!0}),this._shadowCasterContainer.children.length=0,this._useShadowCastersAsOverlay||(this._shadowOverlayContainer.children.forEach((t=>{t._activeParentLayer=null})),t.render(this._shadowOverlayContainer,{renderTexture:this._shadowOverlayResultTexture,clear:!0,skipUpdateTransform:!0}),this._shadowOverlayContainer.children.length=0);const e=this._useShadowCastersAsOverlay?this._shadowCasterResultSprite:this._shadowOverlayResultSprite;this._maskContainer.children.forEach((i=>{i instanceof d&&(i.renderStep=!0,i.update(t,this._shadowCasterResultSprite,e))})),t.render(this._maskContainer,{renderTexture:this._maskResultTexture,clear:!0,skipUpdateTransform:!0}),this._maskContainer.children.forEach((t=>{t instanceof d&&delete t.renderStep})),this._maskContainer.children.length=0}apply(t,e,i,n){const s=this._maskResultSprite,r=this._maskResultSprite.texture;r.valid&&(this.uniforms.mask=r,this.uniforms.otherMatrix=t.calculateSpriteMatrix(this._maskMatrix,s),t.applyFilter(this,e,i,n))}set ambientLight(t){this.uniforms.ambientLight=t}get ambientLight(){return this.uniforms.ambientLight}set width(t){this._width=t,this.uniforms.size=[this._width,this._height],this.__createOverlaySources(),this.__createCasterSources(),this.__createMaskSources()}get width(){return this._width}set height(t){this._height=t,this.uniforms.size=[this._width,this._height],this.__createOverlaySources(),this.__createCasterSources(),this.__createMaskSources()}get height(){return this._height}set useShadowCasterAsOverlay(t){this._useShadowCastersAsOverlay=t}get useShadowCasterAsOverlay(){return this._useShadowCastersAsOverlay}}function c(t,i){t.stage=new e.Stage,t.ticker.remove(t.render,t),t.render=function(){const t=this.stage.parent;this.stage.parent=this.stage,this.stage.updateTransform(),this.stage.parent=t,i.update(this.renderer),this.renderer.render(this.stage,{skipUpdateTransform:!0})},t.ticker=t.ticker}function p(t,e,n){const s=i.Container.prototype.updateTransform,r=new WeakMap;i.Container.prototype.updateTransform=function(...i){return this.parentGroup===t&&(r.get(this)!==n.tick&&n._shadowCasterContainer.children.push(this),r.set(this,n.tick)),this.parentGroup===e&&(r.get(this)!==n.tick&&n._shadowOverlayContainer.children.push(this),r.set(this,n.tick)),this instanceof d&&(r.get(this)!==n.tick&&n._maskContainer.children.push(this),r.set(this,n.tick)),s.apply(this,i)}}class f{__init(){this.casterGroup=new e.Group}__init2(){this.overlayGroup=new e.Group}__init3(){this.container=new i.Container}constructor(t,i){if(f.prototype.__init.call(this),f.prototype.__init2.call(this),f.prototype.__init3.call(this),this.filter=new u(t.renderer.width,t.renderer.height),p(this.casterGroup,this.overlayGroup,this.filter),c(t,this.filter),t.stage.addChild(this.container),function(t){let e,i=t[0],n=1;for(;n<t.length;){const s=t[n],r=t[n+1];if(n+=2,("optionalAccess"===s||"optionalCall"===s)&&null==i)return;"access"===s||"optionalAccess"===s?(e=i,i=r(i)):"call"!==s&&"optionalCall"!==s||(i=r(((...t)=>i.call(e,...t))),e=void 0)}return i}([i,"optionalAccess",t=>t.pixiLights])){const n=new e.Layer(i.pixiLights.diffuseGroup),s=new e.Layer(i.pixiLights.normalGroup),r=new e.Layer(i.pixiLights.lightGroup),o=new a.Sprite(n.getRenderTexture());o.tint=0,t.stage.addChild(n,o,s,r),t.stage.filters=[this.filter]}else this.container.filters=[this.filter]}}const g={init(t){this.shadows=new f(this,t.fov)},destroy(){delete this.shadows}};t.AppLoaderPlugin=g,t.Shadow=d,t.ShadowFilter=u,t.ShadowMaskFilter=l,t.Shadows=f,t.augmentApplication=c,t.augmentContainer=p,t.filterFuncs=o,Object.defineProperty(t,"__esModule",{value:!0})})),"undefined"!=typeof pixi_shadows&&Object.assign(this.PIXI.shadows,pixi_shadows);
//# sourceMappingURL=pixi-shadows.umd.min.js.map
