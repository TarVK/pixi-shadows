{"version":3,"file":"pixi-shadows.umd.min.js","sources":["../src/filters/FilterFuncs.ts","../src/filters/ShadowMapFilter.ts","../src/filters/ShadowMaskFilter.ts","../src/Shadow.ts","../src/filters/ShadowFilter.ts","../src/mixins/Application.ts","../src/mixins/Container.ts","../src/index.ts"],"sourcesContent":["// Some functions to map a value as a color\r\nexport const filterFuncs = /*glsl*/ `\r\nfloat colorToFloat(vec4 color){\r\n    return (color.r + (color.g + color.b * 256.0) * 256.0) * 255.0 - 8388608.0;\r\n}\r\nvec4 floatToColor(float f){\r\n    f += 8388608.0;\r\n    vec4 color;\r\n    color.a = 255.0;\r\n    color.b = floor(f / 256.0 / 256.0);\r\n    color.g = floor((f - color.b * 256.0 * 256.0) / 256.0);\r\n    color.r = floor(f - color.b * 256.0 * 256.0 - color.g * 256.0);\r\n    return color / 255.0;\r\n}\r\n`;\r\n","import { Filter, FilterSystem, RenderTexture } from '@pixi/core';\r\n\r\nimport { CLEAR_MODES } from '@pixi/constants';\r\nimport { Matrix } from '@pixi/math';\r\nimport { Shadow } from '../Shadow';\r\nimport { filterFuncs } from './FilterFuncs';\r\n\r\nconst maxDepthResolution = '2000.0';\r\n\r\nexport class ShadowMapFilter extends Filter {\r\n    autoFit = false;\r\n    padding = 0;\r\n    ignoreShadowCasterMatrix = new Matrix();\r\n\r\n    constructor(private shadow: Shadow) {\r\n        super(\r\n            /* glsl*/ `\r\n            attribute vec2 aVertexPosition;\r\n            attribute vec2 aTextureCoord;\r\n            \r\n            uniform mat3 projectionMatrix;\r\n            uniform mat3 filterMatrix;\r\n            \r\n            varying vec2 vTextureCoord;\r\n            varying vec2 vFilterCoord;\r\n            \r\n            void main(void){\r\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n                vTextureCoord = aTextureCoord;\r\n            }\r\n        `,\r\n            /* glsl*/ `\r\n            varying vec2 vMaskCoord;\r\n            varying vec2 vTextureCoord;\r\n            uniform vec4 filterArea;\r\n            \r\n            uniform sampler2D shadowCasterSampler;\r\n            uniform vec2 shadowCasterSpriteDimensions;\r\n\r\n            uniform bool hasIgnoreShadowCaster;\r\n            uniform sampler2D ignoreShadowCasterSampler;\r\n            uniform mat3 ignoreShadowCasterMatrix;\r\n            uniform vec2 ignoreShadowCasterDimensions;\r\n\r\n            uniform float lightRange;\r\n            uniform float lightScatterRange;\r\n            uniform vec2 lightLoc;\r\n\r\n            uniform float depthResolution;\r\n            uniform bool darkenOverlay;\r\n\r\n            uniform vec2 dimensions;\r\n\r\n            ${filterFuncs}\r\n            \r\n            void main(void){\r\n                float pi = 3.141592653589793238462643;\r\n                \r\n                // Cap the depthResolution (as I expect performance loss by having a big value, but I am not sure)\r\n                float depthRes = min(${maxDepthResolution}, depthResolution);\r\n\r\n                // The current coordinate on the texutre measured in pixels, as well as a fraction\r\n                vec2 pixelCoord = vTextureCoord * filterArea.xy;\r\n                vec2 normalizedCoord = pixelCoord / dimensions;\r\n                \r\n                // Extract the components of the normalized coordinate\r\n                float x = normalizedCoord.x;\r\n                float y = normalizedCoord.y;\r\n\r\n                // Calculate the offset of the lightPoint we are currently at\r\n                float offsetAngle = 2.0 * pi * y;\r\n                vec2 offset = vec2(cos(offsetAngle), sin(offsetAngle)) * lightScatterRange;\r\n\r\n                // Calculate the angle at which we are ray tracing\r\n                float angle = x * pi * 2.0;\r\n\r\n                // The distance at which we hit an object\r\n                float hitDistancePer = 1.0;\r\n\r\n                // Increase the distance until we hit an object or reach the maximum value\r\n                bool reached = false;\r\n                for(float dist=0.0; dist < ${maxDepthResolution}; dist+=1.0){\r\n                    if(dist > depthRes) break;\r\n                    \r\n                    // Calculate the actual distance in pixel units, and use it to calculate the pixel coordinate to inspect\r\n                    float distance = dist / depthRes * lightRange;\r\n                    vec2 coord = lightLoc + offset + vec2(cos(angle), sin(angle)) * distance;\r\n                \r\n                    // Extract the pixel and check if it is opaque\r\n                    float opacity = texture2D(shadowCasterSampler, coord / shadowCasterSpriteDimensions).a;\r\n                    if((opacity > 0.0 && darkenOverlay) || opacity > 0.5){\r\n                        // Check if it isn't hitting something that should be ignore\r\n                        if(hasIgnoreShadowCaster){ \r\n                            vec2 l = (ignoreShadowCasterMatrix * vec3(coord, 1.0)).xy / ignoreShadowCasterDimensions;\r\n                            if(l.x >= -0.01 && l.x <= 1.01 && l.y >= -0.01 && l.y <= 1.01){\r\n                                // If the pixel at the ignoreShadowCaster is opaque here, skip this pixel\r\n                                if(opacity > 0.0){\r\n                                    continue;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // Calculate the percentage at which this hit occurred, and stop the loop\r\n                        if(!darkenOverlay){\r\n                            hitDistancePer = distance / lightRange;\r\n                            break;\r\n                        }\r\n                        reached = true;\r\n                    }else if(reached){\r\n                        hitDistancePer = (distance - 1.0) / lightRange;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // Express the distance as a color in the map\r\n                gl_FragColor = floatToColor(hitDistancePer * 100000.0);\r\n            }\r\n        `\r\n        );\r\n        this.uniforms.lightPointCount = shadow.pointCount;\r\n        this.uniforms.dimensions = [shadow.radialResolution, shadow.pointCount];\r\n    }\r\n\r\n    apply(filterManager: FilterSystem, input: RenderTexture, output: RenderTexture, clearMode?: CLEAR_MODES) {\r\n        // Decide whether or not to darken the overlays\r\n        this.uniforms.darkenOverlay = this.shadow.darkenOverlay;\r\n\r\n        // Attach the object sampler\r\n        const sc = this.shadow._shadowCasterSprite;\r\n\r\n        this.uniforms.shadowCasterSpriteDimensions = [sc.width, sc.height];\r\n        this.uniforms.shadowCasterSampler = sc._texture;\r\n\r\n        // Use the world transform (data about the absolute location on the screen) to determine the lights relation to the objectSampler\r\n        const wt = this.shadow.worldTransform;\r\n        const scale = Math.sqrt(wt.a * wt.a + wt.b * wt.b);\r\n        const range = this.shadow.range * scale;\r\n\r\n        this.uniforms.lightRange = range;\r\n        this.uniforms.lightScatterRange = this.shadow.scatterRange;\r\n        this.uniforms.lightLoc = [wt.tx, wt.ty];\r\n        this.uniforms.depthResolution = range * this.shadow.depthResolution;\r\n\r\n        // Check if there is an object that the filter should attempt to ignore\r\n        const isc = this.shadow.ignoreShadowCaster;\r\n\r\n        this.uniforms.hasIgnoreShadowCaster = !!isc;\r\n        if (isc) {\r\n            // Calculate the tranform matrix in order to access the proper pixel of the ignoreObject\r\n            isc.worldTransform.copyFrom(this.ignoreShadowCasterMatrix);\r\n            this.uniforms.ignoreShadowCasterMatrix = this.ignoreShadowCasterMatrix.invert();\r\n\r\n            // Attach the ignore object\r\n            this.uniforms.ignoreShadowCasterDimensions = [isc.width, isc.height];\r\n            this.uniforms.ignoreShadowCasterSampler = isc._texture;\r\n        }\r\n\r\n        // Apply the filter\r\n        filterManager.applyFilter(this, input, output, clearMode);\r\n    }\r\n}\r\n","import { Filter, FilterSystem, RenderTexture } from '@pixi/core';\r\n\r\nimport { CLEAR_MODES } from '@pixi/constants';\r\nimport { Matrix } from '@pixi/math';\r\nimport { Shadow } from '../Shadow';\r\nimport { filterFuncs } from './FilterFuncs';\r\n\r\nexport class ShadowMaskFilter extends Filter {\r\n    private inverted = false;\r\n\r\n    autoFit = false;\r\n    padding = 0;\r\n    overlayMatrix = new Matrix();\r\n\r\n    constructor(private shadow: Shadow) {\r\n        super(\r\n            /* glsl*/ `\r\n            attribute vec2 aVertexPosition;\r\n            attribute vec2 aTextureCoord;\r\n            \r\n            uniform mat3 projectionMatrix;\r\n            uniform mat3 overlayMatrix;\r\n            uniform mat3 filterMatrix;\r\n            \r\n            varying vec2 vTextureCoord;\r\n            varying vec2 vOverlayCoord;\r\n            varying vec2 vFilterCoord;\r\n            \r\n            void main(void){\r\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n                vTextureCoord = aTextureCoord;\r\n                vOverlayCoord = (overlayMatrix * vec3(aTextureCoord, 1.0) ).xy;\r\n            }\r\n        `,\r\n            /* glsl*/ `\r\n            varying vec2 vOverlayCoord;\r\n            varying vec2 vTextureCoord;\r\n            uniform vec4 filterArea;\r\n            \r\n            uniform sampler2D shadowOverlaySampler;\r\n\r\n            uniform vec2 dimensions;\r\n\r\n            uniform sampler2D shadowSampler;\r\n\r\n            uniform bool darkenOverlay;\r\n            uniform bool inverted;\r\n\r\n            uniform float overlayLightLength;\r\n\r\n            uniform float lightPointCount;\r\n            uniform float lightRange;\r\n            uniform float lightScatterRange;\r\n            uniform float lightIntensity;\r\n            uniform float fallOffFraction;\r\n\r\n            ${filterFuncs}\r\n            \r\n            void main(void){\r\n                float pi = 3.141592653589793238462643;\r\n                \r\n                // The current coordinate on the texture measured in pixels\r\n                vec2 pixelCoord = vTextureCoord * filterArea.xy;\r\n\r\n                // The distance delta relative to the center\r\n                vec2 lightDelta = pixelCoord - dimensions / 2.0;\r\n                float distance = sqrt(lightDelta.x * lightDelta.x + lightDelta.y * lightDelta.y);\r\n                if (distance > lightRange) return;\r\n\r\n                // The final intensity of the light at this pixel\r\n                float totalIntensity = 0.0;\r\n\r\n                // The intensity of the pixel in the overlay map at this pixel\r\n                vec4 overlayPixel = texture2D(shadowOverlaySampler, vOverlayCoord);\r\n\r\n                // Go through all light points (at most 1000) to add them to the intensity\r\n                for(float lightIndex=0.0; lightIndex<1000.0; lightIndex++){\r\n                    if (lightIndex >= lightPointCount) break; // Stop the loop if we went over the pointCount\r\n\r\n                    // Calculate the offset of this lightPoint, relative the the center of the light\r\n                    float lightIndexFrac = (lightIndex + 0.5) / lightPointCount;\r\n                    float offsetAngle = 2.0 * pi * lightIndexFrac;\r\n                    vec2 offset = vec2(cos(offsetAngle), sin(offsetAngle)) * lightScatterRange;\r\n\r\n                    // Calculate the location of this pixel relative to the lightPoint, and check the depth map\r\n                    vec2 pointDelta = lightDelta - offset;\r\n                    float pointDistance = sqrt(pointDelta.x * pointDelta.x + pointDelta.y * pointDelta.y);\r\n                    float angle = mod(atan(pointDelta.y, pointDelta.x) + 2.0 * pi, 2.0 * pi);\r\n                    vec4 depthPixel = texture2D(shadowSampler, vec2(angle / (2.0 * pi), lightIndexFrac));\r\n\r\n                    // Extract the object distance from the depth map pixel\r\n                    float objectDistance = colorToFloat(depthPixel) / 100000.0 * lightRange;\r\n                    \r\n                    // Calculate the intensity of this pixel based on the overlaySampler and objectDistance\r\n                    float distFromEdge = lightRange - distance;\r\n                    float fallOffDist = lightRange * fallOffFraction;\r\n                    float defaultIntensity = min(1.0, distFromEdge/fallOffDist);\r\n\r\n\r\n                    float intensity = 0.0;\r\n                    if (darkenOverlay) {\r\n                        if (objectDistance > pointDistance || objectDistance >= lightRange) {\r\n                            intensity = defaultIntensity;\r\n                        }else if (overlayPixel.a > 0.5) {\r\n                            intensity = defaultIntensity * pow(1.0 - (distance - objectDistance) / (lightRange - objectDistance), 2.5) * overlayPixel.a;\r\n                        }\r\n                    } else {\r\n                        if (inverted) {\r\n                            if (overlayPixel.a > 0.5) {\r\n                                intensity = 1.0-overlayPixel.a;\r\n                            }else if (objectDistance > pointDistance || objectDistance >= lightRange) {\r\n                                intensity = 0.0;\r\n                            }else{\r\n                                intensity = 1.0;\r\n                            }\r\n                        }else{\r\n                            if (objectDistance > pointDistance || objectDistance >= lightRange) {\r\n                                intensity = defaultIntensity;\r\n                            }else if (overlayPixel.a > 0.5) {\r\n                                intensity = defaultIntensity * (1.0 - (pointDistance - objectDistance) / overlayLightLength);\r\n                            }\r\n                        }\r\n                    }\r\n                    \r\n\r\n                    // Add the intensity to the total intensity\r\n                    totalIntensity += intensity / lightPointCount;\r\n                }\r\n\r\n                // Create a mask based on the intensity\r\n                gl_FragColor = vec4(vec3(lightIntensity * totalIntensity), 1.0);\r\n            }\r\n        `\r\n        );\r\n\r\n        this.uniforms.shadowSampler = shadow._shadowMapResultTexture;\r\n        this.uniforms.lightPointCount = shadow.pointCount;\r\n    }\r\n\r\n    apply(filterManager: FilterSystem, input: RenderTexture, output: RenderTexture, clearMode?: CLEAR_MODES) {\r\n        // Update simple uniforms\r\n        this.uniforms.fallOffFraction = this.shadow.fallOffFraction;\r\n        this.uniforms.darkenOverlay = this.shadow.darkenOverlay;\r\n\r\n        // Attach the object sampler\r\n        const sc = this.shadow._shadowOverlaySprite;\r\n\r\n        this.uniforms.shadowOverlaySpriteDimensions = [sc.width, sc.height];\r\n        this.uniforms.shadowOverlaySampler = sc._texture;\r\n\r\n        // Use the world transform (data about the absolute location on the screen) to determine the lights relation to the objectSampler\r\n        const wt = this.shadow.worldTransform;\r\n        const scale = Math.sqrt(wt.a * wt.a + wt.b * wt.b);\r\n        const range = this.shadow.range * scale;\r\n\r\n        this.uniforms.lightRange = range;\r\n        this.uniforms.lightScatterRange = this.shadow.scatterRange;\r\n        this.uniforms.lightIntensity = this.shadow.intensity;\r\n\r\n        // The length of the area of the overlay to be lit\r\n        this.uniforms.overlayLightLength = this.shadow.overlayLightLength;\r\n\r\n        // Invert the filter if specified\r\n        this.uniforms.inverted = this.inverted;\r\n\r\n        // Texture size increase in order to fit the sprite rectangle (even though we are only interested in a circle)\r\n        // So we have to consider this in the texture size\r\n        const texSize = 2 * this.shadow.range * (wt.a + wt.b);\r\n\r\n        this.uniforms.dimensions = [texSize, texSize];\r\n\r\n        // Calculate the object sampler position in relation to the light\r\n        this.uniforms.overlayMatrix = filterManager.calculateSpriteMatrix(this.overlayMatrix, sc);\r\n\r\n        // Apply the filter\r\n        filterManager.applyFilter(this, input, output, clearMode);\r\n    }\r\n}\r\n","import { BLEND_MODES, SCALE_MODES } from '@pixi/constants';\r\n\r\nimport { Application } from '@pixi/app';\r\nimport { RenderTexture } from '@pixi/core';\r\nimport { ShadowMapFilter } from './filters/ShadowMapFilter';\r\nimport { ShadowMaskFilter } from './filters/ShadowMaskFilter';\r\nimport { Sprite } from '@pixi/sprite';\r\n\r\n/**\r\n * @class\r\n * @memberof PIXI.shadows\r\n *\r\n * @param range {number} The radius of the lit area in pixels.\r\n * @param [intensity=1] {number} The opacity of the lit area.\r\n * @param [pointCount=20] {number} The number of points that makes up this light.\r\n * @param [scatterRange=15] {number} The radius at which the points of the light should be scattered.\r\n */\r\n\r\nexport class Shadow extends Sprite {\r\n    /**\r\n     * The of steps to take per pixel. (Higher resolution = more precise edges + more intensive).\r\n     */\r\n    depthResolution = 1; // per screen pixel\r\n    /**\r\n     * Whther or not overlays in shadows should become darker (can create odd artifacts, is very experimental/unfinished)\r\n     */\r\n    darkenOverlay = false;\r\n\r\n    /**\r\n     * How many pixels of the overlay should be lit up by the light\r\n     */\r\n    overlayLightLength = Infinity;\r\n\r\n    /**\r\n     * A shadow caster to ignore while creating the shadows. (Can be used if sprite and light always overlap).\r\n     */\r\n    ignoreShadowCaster: Sprite | undefined;\r\n\r\n    /**\r\n     * The fraction of the range over which the light will fall-off linearly\r\n     */\r\n    fallOffFraction = 1.0;\r\n\r\n    shadowFilter: ShadowMaskFilter;\r\n    renderStep: boolean | undefined;\r\n    shadowMapResultSprite: Sprite | undefined;\r\n\r\n    _shadowCasterSprite: Sprite | undefined;\r\n    _shadowOverlaySprite: Sprite | undefined;\r\n    _shadowMapResultTexture: RenderTexture | undefined;\r\n\r\n    private _shadowMapSprite: Sprite | undefined;\r\n\r\n    /**\r\n     * @param range The radius of the lit area in pixels.\r\n     * @param intensity The opacity of the lit area.\r\n     * @param pointCount The number of points that makes up this light.\r\n     * @param scatterRange The radius at which the points of the light should be scattered.\r\n     */\r\n    constructor(\r\n        private _range: number,\r\n        /**\r\n         * The opacity of the lit area. (may exceed 1).\r\n         */\r\n        public intensity: number = 1,\r\n        private _pointCount: number = 20,\r\n        /**\r\n         * The radius at which the points of the light should be scattered. (Greater range = softer shadow boundary).\r\n         */\r\n        public scatterRange: number = _pointCount === 1 ? 0 : 15,\r\n        private _radialResolution = 800\r\n    ) {\r\n        super(\r\n            RenderTexture.create({\r\n                width: _range * 2,\r\n                height: _range * 2,\r\n            })\r\n        );\r\n\r\n        this.anchor.set(0.5);\r\n\r\n        this.__createShadowMapSources();\r\n    }\r\n    // Create the texture to apply this mask filter to\r\n    __updateTextureSize() {\r\n        this.texture.destroy();\r\n        this.texture = RenderTexture.create({\r\n            width: this._range * 2,\r\n            height: this._range * 2,\r\n        });\r\n    }\r\n    // Create the resources that create the shadow map\r\n    __createShadowMapSources() {\r\n        if (this._shadowMapSprite) this._shadowMapSprite.destroy();\r\n        if (this.shadowMapResultSprite) this.shadowMapResultSprite.destroy();\r\n        if (this._shadowMapResultTexture) this._shadowMapResultTexture.destroy();\r\n\r\n        // A blank texture/sprite to apply the filter to\r\n        this._shadowMapResultTexture = RenderTexture.create({\r\n            width: this._radialResolution,\r\n            height: this._pointCount,\r\n        });\r\n        this._shadowMapResultTexture.baseTexture.scaleMode = SCALE_MODES.NEAREST;\r\n        this._shadowMapSprite = new Sprite(this._shadowMapResultTexture);\r\n        this._shadowMapSprite.filters = [new ShadowMapFilter(this)];\r\n\r\n        // The resulting texture/sprite after the filter has been applied\r\n        this.shadowMapResultSprite = new Sprite(this._shadowMapResultTexture);\r\n\r\n        // Create the mask filter\r\n        const filter = new ShadowMaskFilter(this);\r\n\r\n        filter.blendMode = BLEND_MODES.ADD;\r\n        this.shadowFilter = filter;\r\n        this.filters = [filter];\r\n    }\r\n    // Properly dispose all the created resources\r\n    destroy() {\r\n        if (this._shadowMapSprite) this._shadowMapSprite.destroy();\r\n        if (this.shadowMapResultSprite) this.shadowMapResultSprite.destroy();\r\n        if (this._shadowMapResultTexture) this._shadowMapResultTexture.destroy();\r\n        this.texture.destroy();\r\n\r\n        return super.destroy();\r\n    }\r\n    // Don't render this sprite unless we are in the dedicated render step called by the shadow filter\r\n    renderAdvanced(renderer: any) {\r\n        if (this.renderStep) super.renderAdvanced(renderer);\r\n    }\r\n\r\n    // Update the map to create the mask from\r\n    update(renderer: Application['renderer'], shadowCasterSprite: Sprite, shadowOverlaySprite: Sprite) {\r\n        this._shadowCasterSprite = shadowCasterSprite;\r\n        this._shadowOverlaySprite = shadowOverlaySprite;\r\n        renderer.render(this._shadowMapSprite, {\r\n            renderTexture: this._shadowMapResultTexture,\r\n            clear: true,\r\n            skipUpdateTransform: true,\r\n        });\r\n    }\r\n\r\n    // Attribute getters + setters\r\n\r\n    /**\r\n     * @type {number} The radius of the lit area in pixels.\r\n     */\r\n    set range(range) {\r\n        this._range = range;\r\n        this.__updateTextureSize();\r\n    }\r\n    get range() {\r\n        return this._range;\r\n    }\r\n\r\n    /**\r\n     * @type {number} The number of points that makes up this light, for soft shadows. (More points = softer shadow edges + more intensive).\r\n     */\r\n    set pointCount(count) {\r\n        this._pointCount = count;\r\n        this.__createShadowMapSources();\r\n    }\r\n    get pointCount() {\r\n        return this._pointCount;\r\n    }\r\n\r\n    /**\r\n     * @type {number} The number of rays to draw for the light. (Higher resolution = more precise edges + more intensive).\r\n     */\r\n    set radialResolution(resolution) {\r\n        this._radialResolution = resolution;\r\n        this.__createShadowMapSources();\r\n    }\r\n    get radialResolution() {\r\n        return this._radialResolution;\r\n    }\r\n}\r\n","import { CLEAR_MODES, SCALE_MODES } from '@pixi/constants';\r\nimport { Filter, FilterSystem, RenderTexture } from '@pixi/core';\r\n\r\nimport { Application } from '@pixi/app';\r\nimport { Container } from '@pixi/display';\r\nimport { Matrix } from '@pixi/math';\r\nimport { Shadow } from '../Shadow';\r\nimport { Sprite } from '@pixi/sprite';\r\n\r\nexport class ShadowFilter extends Filter {\r\n    public tick = 0;\r\n    private _useShadowCastersAsOverlay = true;\r\n    _shadowOverlayResultTexture: RenderTexture | undefined;\r\n    _shadowOverlayResultSprite: Sprite | undefined;\r\n    _shadowOverlayContainer: Container | undefined;\r\n    _shadowCasterResultTexture: RenderTexture | undefined;\r\n    _shadowCasterResultSprite: Sprite | undefined;\r\n    _shadowCasterContainer: Container | undefined;\r\n    _maskResultTexture: RenderTexture | undefined;\r\n    _maskResultSprite: Sprite | undefined;\r\n    _maskContainer: Container | undefined;\r\n    _maskMatrix: Matrix | undefined;\r\n    constructor(private _width: number, private _height: number) {\r\n        super(\r\n            /* glsl*/ `\r\n            attribute vec2 aVertexPosition;\r\n            attribute vec2 aTextureCoord;\r\n            \r\n            uniform mat3 projectionMatrix;\r\n            uniform mat3 otherMatrix;\r\n            \r\n            varying vec2 vMaskCoord;\r\n            varying vec2 vTextureCoord;\r\n            \r\n            void main(void)\r\n            {\r\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n            \r\n                vTextureCoord = aTextureCoord;\r\n                vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\r\n            }\r\n        `,\r\n            /* glsl*/ `                    \r\n            varying vec2 vMaskCoord;\r\n            varying vec2 vTextureCoord;\r\n            \r\n            uniform sampler2D uSampler;\r\n            uniform sampler2D mask;\r\n            uniform vec4 maskClamp;\r\n            uniform float ambientLight;\r\n            \r\n            void main(void){            \r\n                vec4 original = texture2D(uSampler, vTextureCoord);\r\n                vec4 masky = texture2D(mask, vMaskCoord);\r\n            \r\n                original *= ambientLight + (1.0 - ambientLight) * (masky.r + masky.g + masky.b) / 3.0;\r\n            \r\n                gl_FragColor = original;\r\n            }\r\n        `\r\n        );\r\n\r\n        this.uniforms.ambientLight = 0.0;\r\n        this.uniforms.size = [this._width, this._height];\r\n\r\n        this.__createCasterSources();\r\n        this.__createOverlaySources();\r\n        this.__createMaskSources();\r\n    }\r\n    // Shadow overlay objects\r\n    __createOverlaySources() {\r\n        if (this._shadowOverlayResultTexture) this._shadowOverlayResultTexture.destroy();\r\n        if (this._shadowOverlayResultSprite) this._shadowOverlayResultSprite.destroy();\r\n\r\n        if (!this._shadowOverlayContainer) this._shadowOverlayContainer = new Container();\r\n\r\n        // Create the final mask to apply to the container that this filter is applied to\r\n        this._shadowOverlayResultTexture = RenderTexture.create({ width: this._width, height: this._height });\r\n        this._shadowOverlayResultTexture.baseTexture.scaleMode = SCALE_MODES.NEAREST;\r\n        this._shadowOverlayResultSprite = new Sprite(this._shadowOverlayResultTexture);\r\n    }\r\n    // Shadow caster objects\r\n    __createCasterSources() {\r\n        if (this._shadowCasterResultTexture) this._shadowCasterResultTexture.destroy();\r\n        if (this._shadowCasterResultSprite) this._shadowCasterResultSprite.destroy();\r\n\r\n        if (!this._shadowCasterContainer) this._shadowCasterContainer = new Container();\r\n\r\n        // Create the final mask to apply to the container that this filter is applied to\r\n        this._shadowCasterResultTexture = RenderTexture.create({ width: this._width, height: this._height });\r\n        this._shadowCasterResultTexture.baseTexture.scaleMode = SCALE_MODES.NEAREST;\r\n        this._shadowCasterResultSprite = new Sprite(this._shadowCasterResultTexture);\r\n    }\r\n    // Final mask to apply as a filter\r\n    __createMaskSources() {\r\n        if (this._maskResultTexture) this._maskResultTexture.destroy();\r\n        if (this._maskResultSprite) this._maskResultSprite.destroy();\r\n\r\n        // Create maskMatrix for shader transform data\r\n        if (!this._maskMatrix) this._maskMatrix = new Matrix();\r\n\r\n        // Create the final mask to apply to the container that this filter is applied to\r\n        this._maskResultTexture = RenderTexture.create({ width: this._width, height: this._height });\r\n        this._maskResultTexture.baseTexture.scaleMode = SCALE_MODES.NEAREST;\r\n        if (!this._maskContainer) this._maskContainer = new Container();\r\n        this._maskResultSprite = new Sprite(this._maskResultTexture);\r\n    }\r\n    // Update the mask texture (called from the Application mixin)\r\n    update(renderer: Application['renderer']) {\r\n        // Shadows and objects will automatically be added to containers because of the Container mixin\r\n\r\n        this.tick++; // Increase the tick so that shadows and objects know they can add themselves to the container again in their next update\r\n\r\n        /* render shadow casters */\r\n        // Remove the parent layer from the objects in order to properly render it to the container\r\n        this._shadowCasterContainer.children.forEach((child) => {\r\n            child._activeParentLayer = null;\r\n        });\r\n\r\n        // Render all the objects onto 1 texture\r\n        renderer.render(this._shadowCasterContainer, {\r\n            renderTexture: this._shadowCasterResultTexture,\r\n            clear: true,\r\n            skipUpdateTransform: true,\r\n        });\r\n\r\n        // Remove all the objects from the container\r\n        this._shadowCasterContainer.children.length = 0;\r\n\r\n        /* render shadow overlays */\r\n        if (!this._useShadowCastersAsOverlay) {\r\n            this._shadowOverlayContainer.children.forEach((child) => {\r\n                child._activeParentLayer = null;\r\n            });\r\n\r\n            // Render all the objects onto 1 texture\r\n            renderer.render(this._shadowOverlayContainer, {\r\n                renderTexture: this._shadowOverlayResultTexture,\r\n                clear: true,\r\n                skipUpdateTransform: true,\r\n            });\r\n\r\n            // Remove all the objects from the container\r\n            this._shadowOverlayContainer.children.length = 0;\r\n        }\r\n\r\n        /* render shadows */\r\n\r\n        // Update all shadows and indicate that they may properly be rendered now\r\n        const overlay = this._useShadowCastersAsOverlay\r\n            ? this._shadowCasterResultSprite\r\n            : this._shadowOverlayResultSprite;\r\n\r\n        this._maskContainer.children.forEach((shadow) => {\r\n            if (shadow instanceof Shadow) {\r\n                shadow.renderStep = true;\r\n                shadow.update(renderer, this._shadowCasterResultSprite, overlay);\r\n            }\r\n        });\r\n\r\n        // Render all the final shadow masks onto 1 texture\r\n        renderer.render(this._maskContainer, {\r\n            renderTexture: this._maskResultTexture,\r\n            clear: true,\r\n            skipUpdateTransform: true,\r\n        });\r\n\r\n        // Indicate that the shadows may no longer render\r\n        this._maskContainer.children.forEach((shadow) => {\r\n            if (shadow instanceof Shadow) {\r\n                delete shadow.renderStep;\r\n            }\r\n        });\r\n\r\n        // Remove all the shadows from the container\r\n        this._maskContainer.children.length = 0;\r\n    }\r\n\r\n    //  Apply the filter to a container\r\n    apply(filterManager: FilterSystem, input: RenderTexture, output: RenderTexture, clearMode?: CLEAR_MODES) {\r\n        // Filter almost directly taken from the pixi mask filter\r\n        const maskSprite = this._maskResultSprite;\r\n        const tex = this._maskResultSprite.texture;\r\n\r\n        if (!tex.valid) {\r\n            return;\r\n        }\r\n\r\n        // TODO: uvMatrix ?\r\n        // if (!tex.transform) {\r\n        //   tex.transform = new TextureMatrix(tex, 0.0);\r\n        // }\r\n\r\n        this.uniforms.mask = tex;\r\n        this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this._maskMatrix, maskSprite);\r\n\r\n        filterManager.applyFilter(this, input, output, clearMode);\r\n    }\r\n\r\n    // Attribute getters + setters\r\n    /**\r\n     * @type {number} The brightness that unlit areas of the world should have\r\n     */\r\n    set ambientLight(frac: number) {\r\n        this.uniforms.ambientLight = frac;\r\n    }\r\n    get ambientLight() {\r\n        return this.uniforms.ambientLight as number;\r\n    }\r\n    /**\r\n     * @type {number} The width of your application\r\n     */\r\n    set width(width) {\r\n        this._width = width;\r\n\r\n        this.uniforms.size = [this._width, this._height];\r\n        this.__createOverlaySources();\r\n        this.__createCasterSources();\r\n        this.__createMaskSources();\r\n    }\r\n    get width() {\r\n        return this._width;\r\n    }\r\n    /**\r\n     * @type {number} The height of your application\r\n     */\r\n    set height(height) {\r\n        this._height = height;\r\n\r\n        this.uniforms.size = [this._width, this._height];\r\n        this.__createOverlaySources();\r\n        this.__createCasterSources();\r\n        this.__createMaskSources();\r\n    }\r\n    get height() {\r\n        return this._height;\r\n    }\r\n    /**\r\n     * @type {boolean} Whether or not to use shadow casters as shadow overlays as well\r\n     */\r\n    set useShadowCasterAsOverlay(val) {\r\n        this._useShadowCastersAsOverlay = val;\r\n    }\r\n\r\n    get useShadowCasterAsOverlay() {\r\n        return this._useShadowCastersAsOverlay;\r\n    }\r\n}\r\n","import '@pixi/ticker';\r\n\r\nimport { Application } from '@pixi/app';\r\nimport { ShadowFilter } from '../filters/ShadowFilter';\r\nimport { Stage } from '@pixi/layers';\r\n\r\nexport function augmentApplication(application: Application, shadowFilter: ShadowFilter) {\r\n    // Replace the stage with a layered stage\r\n    application.stage = new Stage();\r\n\r\n    // Remove the current render function\r\n    // eslint-disable-next-line @typescript-eslint/unbound-method\r\n    application.ticker.remove(application.render, application);\r\n\r\n    // Overwrite the render function\r\n    application.render = function render(this: Application) {\r\n        // Update stage transforms\r\n        const cacheParent = this.stage.parent;\r\n        // this.stage.parent = this.renderer._tempDisplayObjectParent;\r\n        // this.stage.parent = this.stage._tempDisplayObjectParent;\r\n\r\n        this.stage.parent = this.stage;\r\n        this.stage.updateTransform();\r\n        this.stage.parent = cacheParent;\r\n\r\n        // Update the shadow filter\r\n        shadowFilter.update(this.renderer);\r\n\r\n        // Render the stage without updating the transforms again\r\n        this.renderer.render(this.stage, { skipUpdateTransform: true });\r\n    };\r\n\r\n    // Reassign ticker because its setter initialises the render method\r\n    // eslint-disable-next-line no-self-assign\r\n    application.ticker = application.ticker;\r\n}\r\n","import '@pixi/ticker';\r\n\r\nimport { Container } from '@pixi/display';\r\nimport { Group } from '@pixi/layers';\r\nimport { Shadow } from '../Shadow';\r\nimport { ShadowFilter } from '../filters/ShadowFilter';\r\n\r\nexport function augmentContainer(shadowCasterGroup: Group, shadowOverlayGroup: Group, shadowFilter: ShadowFilter) {\r\n    // eslint-disable-next-line @typescript-eslint/unbound-method\r\n    const orTransform: Container['updateTransform'] = Container.prototype.updateTransform;\r\n    const ticks = new WeakMap<Container, number>();\r\n\r\n    Container.prototype.updateTransform = function updateTransform(this: Container, ...args) {\r\n        if (this.parentGroup === shadowCasterGroup) {\r\n            if (ticks.get(this) !== shadowFilter.tick) shadowFilter._shadowCasterContainer.children.push(this);\r\n            ticks.set(this, shadowFilter.tick);\r\n        }\r\n\r\n        if (this.parentGroup === shadowOverlayGroup) {\r\n            if (ticks.get(this) !== shadowFilter.tick) shadowFilter._shadowOverlayContainer.children.push(this);\r\n            ticks.set(this, shadowFilter.tick);\r\n        }\r\n\r\n        if (this instanceof Shadow) {\r\n            if (ticks.get(this) !== shadowFilter.tick) shadowFilter._maskContainer.children.push(this);\r\n            ticks.set(this, shadowFilter.tick);\r\n        }\r\n\r\n        return orTransform.apply(this, args) as ReturnType<Container['updateTransform']>;\r\n    };\r\n}\r\n","import { Application, IApplicationOptions, IApplicationPlugin } from '@pixi/app';\r\nimport { Group, Layer } from '@pixi/layers';\r\n\r\nimport { Container } from '@pixi/display';\r\nimport { ShadowFilter } from './filters/ShadowFilter';\r\nimport { Sprite } from '@pixi/sprite';\r\nimport { augmentApplication } from './mixins/Application';\r\nimport { augmentContainer } from './mixins/Container';\r\n\r\nexport { filterFuncs } from './filters/FilterFuncs';\r\nexport { ShadowFilter } from './filters/ShadowFilter';\r\nexport { ShadowMaskFilter } from './filters/ShadowMaskFilter';\r\nexport { augmentApplication } from './mixins/Application';\r\nexport { augmentContainer } from './mixins/Container';\r\nexport { Shadow } from './Shadow';\r\n\r\nexport interface ShadowsOptions {\r\n    pixiLights?: {\r\n        diffuseGroup: Group;\r\n        normalGroup: Group;\r\n        lightGroup: Group;\r\n    };\r\n}\r\nexport class Shadows {\r\n    // The objects that will cast shadows\r\n    casterGroup = new Group();\r\n    // The objects that will remain ontop of the shadows\r\n    overlayGroup = new Group();\r\n    filter: ShadowFilter;\r\n    container = new Container();\r\n    constructor(app: Application, options?: ShadowsOptions) {\r\n        // // Create the shadow filter\r\n        this.filter = new ShadowFilter(app.renderer.width, app.renderer.height);\r\n        // Set up the container mixin so that it tells the filter about the available shadows and objects\r\n        augmentContainer(this.casterGroup, this.overlayGroup, this.filter);\r\n        // Overwrite the application render method\r\n        augmentApplication(app, this.filter);\r\n        app.stage.addChild(this.container);\r\n\r\n        if (options?.pixiLights) {\r\n            // Set up pixi-light's layers\r\n            const diffuseLayer = new Layer(options.pixiLights.diffuseGroup);\r\n            const normalLayer = new Layer(options.pixiLights.normalGroup);\r\n            const lightLayer = new Layer(options.pixiLights.lightGroup);\r\n            const diffuseBlackSprite = new Sprite(diffuseLayer.getRenderTexture());\r\n\r\n            diffuseBlackSprite.tint = 0;\r\n            // Set up the lighting layers\r\n            app.stage.addChild(diffuseLayer, diffuseBlackSprite, normalLayer, lightLayer);\r\n            // Add the shadow filter to the diffuse layer\r\n            app.stage.filters = [this.filter];\r\n        } else {\r\n            this.container.filters = [this.filter];\r\n        }\r\n    }\r\n}\r\ndeclare module '@pixi/app' {\r\n    export interface Application {\r\n        shadows: Shadows;\r\n    }\r\n    export interface IApplicationOptions {\r\n        fov?: ShadowsOptions;\r\n    }\r\n}\r\n\r\nexport const AppLoaderPlugin: IApplicationPlugin = {\r\n    init(this: Application, options: IApplicationOptions): void {\r\n        this.shadows = new Shadows(this, options.fov);\r\n    },\r\n    destroy(this: Application): void {\r\n        delete this.shadows;\r\n    },\r\n};\r\n"],"names":["filterFuncs","ShadowMapFilter","Filter","__init","this","autoFit","__init2","padding","__init3","ignoreShadowCasterMatrix","Matrix","constructor","shadow","super","prototype","call","uniforms","lightPointCount","pointCount","dimensions","radialResolution","apply","filterManager","input","output","clearMode","darkenOverlay","sc","_shadowCasterSprite","shadowCasterSpriteDimensions","width","height","shadowCasterSampler","_texture","wt","worldTransform","scale","Math","sqrt","a","b","range","lightRange","lightScatterRange","scatterRange","lightLoc","tx","ty","depthResolution","isc","ignoreShadowCaster","hasIgnoreShadowCaster","copyFrom","invert","ignoreShadowCasterDimensions","ignoreShadowCasterSampler","applyFilter","ShadowMaskFilter","inverted","__init4","overlayMatrix","shadowSampler","_shadowMapResultTexture","fallOffFraction","_shadowOverlaySprite","shadowOverlaySpriteDimensions","shadowOverlaySampler","lightIntensity","intensity","overlayLightLength","texSize","calculateSpriteMatrix","Shadow","Sprite","Infinity","_range","_pointCount","_radialResolution","RenderTexture","create","anchor","set","__createShadowMapSources","__updateTextureSize","texture","destroy","_shadowMapSprite","shadowMapResultSprite","baseTexture","scaleMode","SCALE_MODES","NEAREST","filters","filter","blendMode","BLEND_MODES","ADD","shadowFilter","renderAdvanced","renderer","renderStep","update","shadowCasterSprite","shadowOverlaySprite","render","renderTexture","clear","skipUpdateTransform","count","resolution","ShadowFilter","tick","_useShadowCastersAsOverlay","_width","_height","ambientLight","size","__createCasterSources","__createOverlaySources","__createMaskSources","_shadowOverlayResultTexture","_shadowOverlayResultSprite","_shadowOverlayContainer","Container","_shadowCasterResultTexture","_shadowCasterResultSprite","_shadowCasterContainer","_maskResultTexture","_maskResultSprite","_maskMatrix","_maskContainer","children","forEach","child","_activeParentLayer","length","overlay","maskSprite","tex","valid","mask","otherMatrix","frac","useShadowCasterAsOverlay","val","augmentApplication","application","stage","Stage","ticker","remove","cacheParent","parent","updateTransform","augmentContainer","shadowCasterGroup","shadowOverlayGroup","orTransform","ticks","WeakMap","args","parentGroup","get","push","Shadows","casterGroup","Group","overlayGroup","container","app","options","addChild","ops","lastAccessLHS","value","i","op","fn","undefined","_optionalChain","_","pixiLights","diffuseLayer","Layer","diffuseGroup","normalLayer","normalGroup","lightLayer","lightGroup","diffuseBlackSprite","getRenderTexture","tint","AppLoaderPlugin","init","shadows","fov"],"mappings":"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"}