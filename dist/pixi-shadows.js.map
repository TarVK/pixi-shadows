{"version":3,"file":"pixi-shadows.js","sources":["../src/filters/FilterFuncs.ts","../src/filters/ShadowMapFilter.ts","../src/filters/ShadowMaskFilter.ts","../src/Shadow.ts","../src/filters/ShadowFilter.ts","../src/mixins/Application.ts","../src/mixins/Container.ts","../src/index.ts"],"sourcesContent":["// Some functions to map a value as a color\nexport const filterFuncs = /*glsl*/ `\nfloat colorToFloat(vec4 color){\n    return (color.r + (color.g + color.b * 256.0) * 256.0) * 255.0 - 8388608.0;\n}\nvec4 floatToColor(float f){\n    f += 8388608.0;\n    vec4 color;\n    color.a = 255.0;\n    color.b = floor(f / 256.0 / 256.0);\n    color.g = floor((f - color.b * 256.0 * 256.0) / 256.0);\n    color.r = floor(f - color.b * 256.0 * 256.0 - color.g * 256.0);\n    return color / 255.0;\n}\n`;\n","import { Filter, FilterSystem, RenderTexture } from '@pixi/core';\n\nimport { CLEAR_MODES } from '@pixi/constants';\nimport { Matrix } from '@pixi/math';\nimport { Shadow } from '../Shadow';\nimport { filterFuncs } from './FilterFuncs';\n\nconst maxDepthResolution = '2000.0';\n\nexport class ShadowMapFilter extends Filter {\n    autoFit = false;\n    padding = 0;\n    ignoreShadowCasterMatrix = new Matrix();\n\n    constructor(private shadow: Shadow) {\n        super(\n            /* glsl*/ `\n            attribute vec2 aVertexPosition;\n            attribute vec2 aTextureCoord;\n            \n            uniform mat3 projectionMatrix;\n            uniform mat3 filterMatrix;\n            \n            varying vec2 vTextureCoord;\n            varying vec2 vFilterCoord;\n            \n            void main(void){\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n                vTextureCoord = aTextureCoord;\n            }\n        `,\n            /* glsl*/ `\n            varying vec2 vMaskCoord;\n            varying vec2 vTextureCoord;\n            uniform vec4 filterArea;\n            \n            uniform sampler2D shadowCasterSampler;\n            uniform vec2 shadowCasterSpriteDimensions;\n\n            uniform bool hasIgnoreShadowCaster;\n            uniform sampler2D ignoreShadowCasterSampler;\n            uniform mat3 ignoreShadowCasterMatrix;\n            uniform vec2 ignoreShadowCasterDimensions;\n\n            uniform float lightRange;\n            uniform float lightScatterRange;\n            uniform vec2 lightLoc;\n\n            uniform float depthResolution;\n            uniform bool darkenOverlay;\n\n            uniform vec2 dimensions;\n\n            ${filterFuncs}\n            \n            void main(void){\n                float pi = 3.141592653589793238462643;\n                \n                // Cap the depthResolution (as I expect performance loss by having a big value, but I am not sure)\n                float depthRes = min(${maxDepthResolution}, depthResolution);\n\n                // The current coordinate on the texutre measured in pixels, as well as a fraction\n                vec2 pixelCoord = vTextureCoord * filterArea.xy;\n                vec2 normalizedCoord = pixelCoord / dimensions;\n                \n                // Extract the components of the normalized coordinate\n                float x = normalizedCoord.x;\n                float y = normalizedCoord.y;\n\n                // Calculate the offset of the lightPoint we are currently at\n                float offsetAngle = 2.0 * pi * y;\n                vec2 offset = vec2(cos(offsetAngle), sin(offsetAngle)) * lightScatterRange;\n\n                // Calculate the angle at which we are ray tracing\n                float angle = x * pi * 2.0;\n\n                // The distance at which we hit an object\n                float hitDistancePer = 1.0;\n\n                // Increase the distance until we hit an object or reach the maximum value\n                bool reached = false;\n                for(float dist=0.0; dist < ${maxDepthResolution}; dist+=1.0){\n                    if(dist > depthRes) break;\n                    \n                    // Calculate the actual distance in pixel units, and use it to calculate the pixel coordinate to inspect\n                    float distance = dist / depthRes * lightRange;\n                    vec2 coord = lightLoc + offset + vec2(cos(angle), sin(angle)) * distance;\n                \n                    // Extract the pixel and check if it is opaque\n                    float opacity = texture2D(shadowCasterSampler, coord / shadowCasterSpriteDimensions).a;\n                    if((opacity > 0.0 && darkenOverlay) || opacity > 0.5){\n                        // Check if it isn't hitting something that should be ignore\n                        if(hasIgnoreShadowCaster){ \n                            vec2 l = (ignoreShadowCasterMatrix * vec3(coord, 1.0)).xy / ignoreShadowCasterDimensions;\n                            if(l.x >= -0.01 && l.x <= 1.01 && l.y >= -0.01 && l.y <= 1.01){\n                                // If the pixel at the ignoreShadowCaster is opaque here, skip this pixel\n                                if(opacity > 0.0){\n                                    continue;\n                                }\n                            }\n                        }\n\n                        // Calculate the percentage at which this hit occurred, and stop the loop\n                        if(!darkenOverlay){\n                            hitDistancePer = distance / lightRange;\n                            break;\n                        }\n                        reached = true;\n                    }else if(reached){\n                        hitDistancePer = (distance - 1.0) / lightRange;\n                        break;\n                    }\n                }\n\n                // Express the distance as a color in the map\n                gl_FragColor = floatToColor(hitDistancePer * 100000.0);\n            }\n        `\n        );\n        this.uniforms.lightPointCount = shadow.pointCount;\n        this.uniforms.dimensions = [shadow.radialResolution, shadow.pointCount];\n    }\n\n    apply(filterManager: FilterSystem, input: RenderTexture, output: RenderTexture, clearMode?: CLEAR_MODES) {\n        // Decide whether or not to darken the overlays\n        this.uniforms.darkenOverlay = this.shadow.darkenOverlay;\n\n        // Attach the object sampler\n        const sc = this.shadow._shadowCasterSprite;\n\n        this.uniforms.shadowCasterSpriteDimensions = [sc.width, sc.height];\n        this.uniforms.shadowCasterSampler = sc._texture;\n\n        // Use the world transform (data about the absolute location on the screen) to determine the lights relation to the objectSampler\n        const wt = this.shadow.worldTransform;\n        const scale = Math.sqrt(wt.a * wt.a + wt.b * wt.b);\n        const range = this.shadow.range * scale;\n\n        this.uniforms.lightRange = range;\n        this.uniforms.lightScatterRange = this.shadow.scatterRange;\n        this.uniforms.lightLoc = [wt.tx, wt.ty];\n        this.uniforms.depthResolution = range * this.shadow.depthResolution;\n\n        // Check if there is an object that the filter should attempt to ignore\n        const isc = this.shadow.ignoreShadowCaster;\n\n        this.uniforms.hasIgnoreShadowCaster = !!isc;\n        if (isc) {\n            // Calculate the tranform matrix in order to access the proper pixel of the ignoreObject\n            isc.worldTransform.copyFrom(this.ignoreShadowCasterMatrix);\n            this.uniforms.ignoreShadowCasterMatrix = this.ignoreShadowCasterMatrix.invert();\n\n            // Attach the ignore object\n            this.uniforms.ignoreShadowCasterDimensions = [isc.width, isc.height];\n            this.uniforms.ignoreShadowCasterSampler = isc._texture;\n        }\n\n        // Apply the filter\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n}\n","import { Filter, FilterSystem, RenderTexture } from '@pixi/core';\n\nimport { CLEAR_MODES } from '@pixi/constants';\nimport { Matrix } from '@pixi/math';\nimport { Shadow } from '../Shadow';\nimport { filterFuncs } from './FilterFuncs';\n\nexport class ShadowMaskFilter extends Filter {\n    private inverted = false;\n\n    autoFit = false;\n    padding = 0;\n    overlayMatrix = new Matrix();\n\n    constructor(private shadow: Shadow) {\n        super(\n            /* glsl*/ `\n            attribute vec2 aVertexPosition;\n            attribute vec2 aTextureCoord;\n            \n            uniform mat3 projectionMatrix;\n            uniform mat3 overlayMatrix;\n            uniform mat3 filterMatrix;\n            \n            varying vec2 vTextureCoord;\n            varying vec2 vOverlayCoord;\n            varying vec2 vFilterCoord;\n            \n            void main(void){\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n                vTextureCoord = aTextureCoord;\n                vOverlayCoord = (overlayMatrix * vec3(aTextureCoord, 1.0) ).xy;\n            }\n        `,\n            /* glsl*/ `\n            varying vec2 vOverlayCoord;\n            varying vec2 vTextureCoord;\n            uniform vec4 filterArea;\n            \n            uniform sampler2D shadowOverlaySampler;\n\n            uniform vec2 dimensions;\n\n            uniform sampler2D shadowSampler;\n\n            uniform bool darkenOverlay;\n            uniform bool inverted;\n\n            uniform float overlayLightLength;\n\n            uniform float lightPointCount;\n            uniform float lightRange;\n            uniform float lightScatterRange;\n            uniform float lightIntensity;\n\n            ${filterFuncs}\n            \n            void main(void){\n                float pi = 3.141592653589793238462643;\n                \n                // The current coordinate on the texture measured in pixels\n                vec2 pixelCoord = vTextureCoord * filterArea.xy;\n\n                // The distance delta relative to the center\n                vec2 lightDelta = pixelCoord - dimensions / 2.0;\n                float distance = sqrt(lightDelta.x * lightDelta.x + lightDelta.y * lightDelta.y);\n                if (distance > lightRange) return;\n\n                // The final intensity of the light at this pixel\n                float totalIntensity = 0.0;\n\n                // The intensity of the pixel in the overlay map at this pixel\n                vec4 overlayPixel = texture2D(shadowOverlaySampler, vOverlayCoord);\n\n                // Go through all light points (at most 1000) to add them to the intensity\n                for(float lightIndex=0.0; lightIndex<1000.0; lightIndex++){\n                    if (lightIndex >= lightPointCount) break; // Stop the loop if we went over the pointCount\n\n                    // Calculate the offset of this lightPoint, relative the the center of the light\n                    float lightIndexFrac = (lightIndex + 0.5) / lightPointCount;\n                    float offsetAngle = 2.0 * pi * lightIndexFrac;\n                    vec2 offset = vec2(cos(offsetAngle), sin(offsetAngle)) * lightScatterRange;\n\n                    // Calculate the location of this pixel relative to the lightPoint, and check the depth map\n                    vec2 pointDelta = lightDelta - offset;\n                    float pointDistance = sqrt(pointDelta.x * pointDelta.x + pointDelta.y * pointDelta.y);\n                    float angle = mod(atan(pointDelta.y, pointDelta.x) + 2.0 * pi, 2.0 * pi);\n                    vec4 depthPixel = texture2D(shadowSampler, vec2(angle / (2.0 * pi), lightIndexFrac));\n\n                    // Extract the object distance from the depth map pixel\n                    float objectDistance = colorToFloat(depthPixel) / 100000.0 * lightRange;\n                    \n                    // Calculate the intensity of this pixel based on the overlaySampler and objectDistance\n                    float intensity = 0.0;\n                    if(darkenOverlay){\n                        if(objectDistance > pointDistance || objectDistance >= lightRange){\n                            intensity = 1.0 - distance / lightRange;\n                        }else if(overlayPixel.a > 0.5){\n                            intensity = 1.0 - distance / lightRange;\n                            intensity *= pow(1.0 - (distance - objectDistance) / (lightRange - objectDistance), 2.5) * overlayPixel.a;\n                        }\n                    }else{\n                        if(inverted){\n                            if(overlayPixel.a > 0.5){\n                                intensity = 1.0-overlayPixel.a;\n                            }else if (objectDistance > pointDistance || objectDistance >= lightRange) {\n                                intensity = 0.0;\n                            }else{\n                                intensity = 1.0;\n                            }\n                        }else{\n                            if (objectDistance > pointDistance || objectDistance >= lightRange) {\n                                intensity = 1.0 - distance / lightRange;\n                            }else if (overlayPixel.a > 0.5) {\n                                intensity = (1.0 - distance / lightRange) * (1.0 - (pointDistance - objectDistance) / overlayLightLength);\n                            }\n                        }\n                    }\n                    \n\n                    // Add the intensity to the total intensity\n                    totalIntensity += intensity / lightPointCount;\n                }\n\n                // Create a mask based on the intensity\n                gl_FragColor = vec4(vec3(lightIntensity * totalIntensity), 1.0);\n            }\n        `\n        );\n\n        this.uniforms.shadowSampler = shadow._shadowMapResultTexture;\n        this.uniforms.lightPointCount = shadow.pointCount;\n    }\n\n    apply(filterManager: FilterSystem, input: RenderTexture, output: RenderTexture, clearMode?: CLEAR_MODES) {\n        // Decide whether or not to darken the overlays\n        this.uniforms.darkenOverlay = this.shadow.darkenOverlay;\n\n        // Attach the object sampler\n        const sc = this.shadow._shadowOverlaySprite;\n\n        this.uniforms.shadowOverlaySpriteDimensions = [sc.width, sc.height];\n        this.uniforms.shadowOverlaySampler = sc._texture;\n\n        // Use the world transform (data about the absolute location on the screen) to determine the lights relation to the objectSampler\n        const wt = this.shadow.worldTransform;\n        const scale = Math.sqrt(wt.a * wt.a + wt.b * wt.b);\n        const range = this.shadow.range * scale;\n\n        this.uniforms.lightRange = range;\n        this.uniforms.lightScatterRange = this.shadow.scatterRange;\n        this.uniforms.lightIntensity = this.shadow.intensity;\n\n        // The length of the area of the overlay to be lit\n        this.uniforms.overlayLightLength = this.shadow.overlayLightLength;\n\n        // Invert the filter if specified\n        this.uniforms.inverted = this.inverted;\n\n        // Texture size increase in order to fit the sprite rectangle (even though we are only interested in a circle)\n        // So we have to consider this in the texture size\n        const texSize = 2 * this.shadow.range * (wt.a + wt.b);\n\n        this.uniforms.dimensions = [texSize, texSize];\n\n        // Calculate the object sampler position in relation to the light\n        this.uniforms.overlayMatrix = filterManager.calculateSpriteMatrix(this.overlayMatrix, sc);\n\n        // Apply the filter\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n}\n","import { BLEND_MODES, SCALE_MODES } from '@pixi/constants';\n\nimport { Application } from '@pixi/app';\nimport { RenderTexture } from '@pixi/core';\nimport { ShadowMapFilter } from './filters/ShadowMapFilter';\nimport { ShadowMaskFilter } from './filters/ShadowMaskFilter';\nimport { Sprite } from '@pixi/sprite';\n\n/**\n * @class\n * @memberof PIXI.shadows\n *\n * @param range {number} The radius of the lit area in pixels.\n * @param [intensity=1] {number} The opacity of the lit area.\n * @param [pointCount=20] {number} The number of points that makes up this light.\n * @param [scatterRange=15] {number} The radius at which the points of the light should be scattered.\n */\n\nexport class Shadow extends Sprite {\n    /**\n     * The of steps to take per pixel. (Higher resolution = more precise edges + more intensive).\n     */\n    depthResolution = 1; // per screen pixel\n    /**\n     * Whther or not overlays in shadows should become darker (can create odd artifacts, is very experimental/unfinished)\n     */\n    darkenOverlay = false;\n\n    /**\n     * How many pixels of the overlay should be lit up by the light\n     */\n    overlayLightLength = Infinity;\n\n    /**\n     * A shadow caster to ignore while creating the shadows. (Can be used if sprite and light always overlap).\n     */\n    ignoreShadowCaster: Sprite | undefined;\n\n    shadowFilter: ShadowMaskFilter;\n    renderStep: boolean | undefined;\n    shadowMapResultSprite: Sprite | undefined;\n\n    _shadowCasterSprite: Sprite | undefined;\n    _shadowOverlaySprite: Sprite | undefined;\n    _shadowMapResultTexture: RenderTexture | undefined;\n\n    private _shadowMapSprite: Sprite | undefined;\n\n    /**\n     * @param range The radius of the lit area in pixels.\n     * @param intensity The opacity of the lit area.\n     * @param pointCount The number of points that makes up this light.\n     * @param scatterRange The radius at which the points of the light should be scattered.\n     */\n    constructor(\n        private _range: number,\n        /**\n         * The opacity of the lit area. (may exceed 1).\n         */\n        public intensity: number = 1,\n        private _pointCount: number = 20,\n        /**\n         * The radius at which the points of the light should be scattered. (Greater range = softer shadow boundary).\n         */\n        public scatterRange: number = _pointCount === 1 ? 0 : 15,\n        private _radialResolution = 800\n    ) {\n        super(\n            RenderTexture.create({\n                width: _range * 2,\n                height: _range * 2,\n            })\n        );\n\n        this.anchor.set(0.5);\n\n        this.__createShadowMapSources();\n    }\n    // Create the texture to apply this mask filter to\n    __updateTextureSize() {\n        this.texture.destroy();\n        this.texture = RenderTexture.create({\n            width: this._range * 2,\n            height: this._range * 2,\n        });\n    }\n    // Create the resources that create the shadow map\n    __createShadowMapSources() {\n        if (this._shadowMapSprite) this._shadowMapSprite.destroy();\n        if (this.shadowMapResultSprite) this.shadowMapResultSprite.destroy();\n        if (this._shadowMapResultTexture) this._shadowMapResultTexture.destroy();\n\n        // A blank texture/sprite to apply the filter to\n        this._shadowMapResultTexture = RenderTexture.create({\n            width: this._radialResolution,\n            height: this._pointCount,\n        });\n        this._shadowMapResultTexture.baseTexture.scaleMode = SCALE_MODES.NEAREST;\n        this._shadowMapSprite = new Sprite(this._shadowMapResultTexture);\n        this._shadowMapSprite.filters = [new ShadowMapFilter(this)];\n\n        // The resulting texture/sprite after the filter has been applied\n        this.shadowMapResultSprite = new Sprite(this._shadowMapResultTexture);\n\n        // Create the mask filter\n        const filter = new ShadowMaskFilter(this);\n\n        filter.blendMode = BLEND_MODES.ADD;\n        this.shadowFilter = filter;\n        this.filters = [filter];\n    }\n    // Properly dispose all the created resources\n    destroy() {\n        if (this._shadowMapSprite) this._shadowMapSprite.destroy();\n        if (this.shadowMapResultSprite) this.shadowMapResultSprite.destroy();\n        if (this._shadowMapResultTexture) this._shadowMapResultTexture.destroy();\n        this.texture.destroy();\n\n        return super.destroy();\n    }\n    // Don't render this sprite unless we are in the dedicated render step called by the shadow filter\n    renderAdvanced(renderer: any) {\n        if (this.renderStep) super.renderAdvanced(renderer);\n    }\n\n    // Update the map to create the mask from\n    update(renderer: Application['renderer'], shadowCasterSprite: Sprite, shadowOverlaySprite: Sprite) {\n        this._shadowCasterSprite = shadowCasterSprite;\n        this._shadowOverlaySprite = shadowOverlaySprite;\n        renderer.render(this._shadowMapSprite, {\n            renderTexture: this._shadowMapResultTexture,\n            clear: true,\n            skipUpdateTransform: true,\n        });\n    }\n\n    // Attribute getters + setters\n\n    /**\n     * @type {number} The radius of the lit area in pixels.\n     */\n    set range(range) {\n        this._range = range;\n        this.__updateTextureSize();\n    }\n    get range() {\n        return this._range;\n    }\n\n    /**\n     * @type {number} The number of points that makes up this light, for soft shadows. (More points = softer shadow edges + more intensive).\n     */\n    set pointCount(count) {\n        this._pointCount = count;\n        this.__createShadowMapSources();\n    }\n    get pointCount() {\n        return this._pointCount;\n    }\n\n    /**\n     * @type {number} The number of rays to draw for the light. (Higher resolution = more precise edges + more intensive).\n     */\n    set radialResolution(resolution) {\n        this._radialResolution = resolution;\n        this.__createShadowMapSources();\n    }\n    get radialResolution() {\n        return this._radialResolution;\n    }\n}\n","import { CLEAR_MODES, SCALE_MODES } from '@pixi/constants';\nimport { Filter, FilterSystem, RenderTexture } from '@pixi/core';\n\nimport { Application } from '@pixi/app';\nimport { Container } from '@pixi/display';\nimport { Matrix } from '@pixi/math';\nimport { Shadow } from '../Shadow';\nimport { Sprite } from '@pixi/sprite';\n\nexport class ShadowFilter extends Filter {\n    public tick = 0;\n    private _useShadowCastersAsOverlay = true;\n    _shadowOverlayResultTexture: RenderTexture | undefined;\n    _shadowOverlayResultSprite: Sprite | undefined;\n    _shadowOverlayContainer: Container | undefined;\n    _shadowCasterResultTexture: RenderTexture | undefined;\n    _shadowCasterResultSprite: Sprite | undefined;\n    _shadowCasterContainer: Container | undefined;\n    _maskResultTexture: RenderTexture | undefined;\n    _maskResultSprite: Sprite | undefined;\n    _maskContainer: Container | undefined;\n    _maskMatrix: Matrix | undefined;\n    constructor(private _width: number, private _height: number) {\n        super(\n            /* glsl*/ `\n            attribute vec2 aVertexPosition;\n            attribute vec2 aTextureCoord;\n            \n            uniform mat3 projectionMatrix;\n            uniform mat3 otherMatrix;\n            \n            varying vec2 vMaskCoord;\n            varying vec2 vTextureCoord;\n            \n            void main(void)\n            {\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n            \n                vTextureCoord = aTextureCoord;\n                vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n            }\n        `,\n            /* glsl*/ `                    \n            varying vec2 vMaskCoord;\n            varying vec2 vTextureCoord;\n            \n            uniform sampler2D uSampler;\n            uniform sampler2D mask;\n            uniform vec4 maskClamp;\n            uniform float ambientLight;\n            \n            void main(void){            \n                vec4 original = texture2D(uSampler, vTextureCoord);\n                vec4 masky = texture2D(mask, vMaskCoord);\n            \n                original *= ambientLight + (1.0 - ambientLight) * (masky.r + masky.g + masky.b) / 3.0;\n            \n                gl_FragColor = original;\n            }\n        `\n        );\n\n        this.uniforms.ambientLight = 0.0;\n        this.uniforms.size = [this._width, this._height];\n\n        this.__createCasterSources();\n        this.__createOverlaySources();\n        this.__createMaskSources();\n    }\n    // Shadow overlay objects\n    __createOverlaySources() {\n        if (this._shadowOverlayResultTexture) this._shadowOverlayResultTexture.destroy();\n        if (this._shadowOverlayResultSprite) this._shadowOverlayResultSprite.destroy();\n\n        if (!this._shadowOverlayContainer) this._shadowOverlayContainer = new Container();\n\n        // Create the final mask to apply to the container that this filter is applied to\n        this._shadowOverlayResultTexture = RenderTexture.create({ width: this._width, height: this._height });\n        this._shadowOverlayResultTexture.baseTexture.scaleMode = SCALE_MODES.NEAREST;\n        this._shadowOverlayResultSprite = new Sprite(this._shadowOverlayResultTexture);\n    }\n    // Shadow caster objects\n    __createCasterSources() {\n        if (this._shadowCasterResultTexture) this._shadowCasterResultTexture.destroy();\n        if (this._shadowCasterResultSprite) this._shadowCasterResultSprite.destroy();\n\n        if (!this._shadowCasterContainer) this._shadowCasterContainer = new Container();\n\n        // Create the final mask to apply to the container that this filter is applied to\n        this._shadowCasterResultTexture = RenderTexture.create({ width: this._width, height: this._height });\n        this._shadowCasterResultTexture.baseTexture.scaleMode = SCALE_MODES.NEAREST;\n        this._shadowCasterResultSprite = new Sprite(this._shadowCasterResultTexture);\n    }\n    // Final mask to apply as a filter\n    __createMaskSources() {\n        if (this._maskResultTexture) this._maskResultTexture.destroy();\n        if (this._maskResultSprite) this._maskResultSprite.destroy();\n\n        // Create maskMatrix for shader transform data\n        if (!this._maskMatrix) this._maskMatrix = new Matrix();\n\n        // Create the final mask to apply to the container that this filter is applied to\n        this._maskResultTexture = RenderTexture.create({ width: this._width, height: this._height });\n        this._maskResultTexture.baseTexture.scaleMode = SCALE_MODES.NEAREST;\n        if (!this._maskContainer) this._maskContainer = new Container();\n        this._maskResultSprite = new Sprite(this._maskResultTexture);\n    }\n    // Update the mask texture (called from the Application mixin)\n    update(renderer: Application['renderer']) {\n        // Shadows and objects will automatically be added to containers because of the Container mixin\n\n        this.tick++; // Increase the tick so that shadows and objects know they can add themselves to the container again in their next update\n\n        /* render shadow casters */\n        // Remove the parent layer from the objects in order to properly render it to the container\n        this._shadowCasterContainer.children.forEach((child) => {\n            child._activeParentLayer = null;\n        });\n\n        // Render all the objects onto 1 texture\n        renderer.render(this._shadowCasterContainer, {\n            renderTexture: this._shadowCasterResultTexture,\n            clear: true,\n            skipUpdateTransform: true,\n        });\n\n        // Remove all the objects from the container\n        this._shadowCasterContainer.children.length = 0;\n\n        /* render shadow overlays */\n        if (!this._useShadowCastersAsOverlay) {\n            this._shadowOverlayContainer.children.forEach((child) => {\n                child._activeParentLayer = null;\n            });\n\n            // Render all the objects onto 1 texture\n            renderer.render(this._shadowOverlayContainer, {\n                renderTexture: this._shadowOverlayResultTexture,\n                clear: true,\n                skipUpdateTransform: true,\n            });\n\n            // Remove all the objects from the container\n            this._shadowOverlayContainer.children.length = 0;\n        }\n\n        /* render shadows */\n\n        // Update all shadows and indicate that they may properly be rendered now\n        const overlay = this._useShadowCastersAsOverlay\n            ? this._shadowCasterResultSprite\n            : this._shadowOverlayResultSprite;\n\n        this._maskContainer.children.forEach((shadow) => {\n            if (shadow instanceof Shadow) {\n                shadow.renderStep = true;\n                shadow.update(renderer, this._shadowCasterResultSprite, overlay);\n            }\n        });\n\n        // Render all the final shadow masks onto 1 texture\n        renderer.render(this._maskContainer, {\n            renderTexture: this._maskResultTexture,\n            clear: true,\n            skipUpdateTransform: true,\n        });\n\n        // Indicate that the shadows may no longer render\n        this._maskContainer.children.forEach((shadow) => {\n            if (shadow instanceof Shadow) {\n                delete shadow.renderStep;\n            }\n        });\n\n        // Remove all the shadows from the container\n        this._maskContainer.children.length = 0;\n    }\n\n    //  Apply the filter to a container\n    apply(filterManager: FilterSystem, input: RenderTexture, output: RenderTexture, clearMode?: CLEAR_MODES) {\n        // Filter almost directly taken from the pixi mask filter\n        const maskSprite = this._maskResultSprite;\n        const tex = this._maskResultSprite.texture;\n\n        if (!tex.valid) {\n            return;\n        }\n\n        // TODO: uvMatrix ?\n        // if (!tex.transform) {\n        //   tex.transform = new TextureMatrix(tex, 0.0);\n        // }\n\n        this.uniforms.mask = tex;\n        this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this._maskMatrix, maskSprite);\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    // Attribute getters + setters\n    /**\n     * @type {number} The brightness that unlit areas of the world should have\n     */\n    set ambientLight(frac: number) {\n        this.uniforms.ambientLight = frac;\n    }\n    get ambientLight() {\n        return this.uniforms.ambientLight as number;\n    }\n    /**\n     * @type {number} The width of your application\n     */\n    set width(width) {\n        this._width = width;\n\n        this.uniforms.size = [this._width, this._height];\n        this.__createOverlaySources();\n        this.__createCasterSources();\n        this.__createMaskSources();\n    }\n    get width() {\n        return this._width;\n    }\n    /**\n     * @type {number} The height of your application\n     */\n    set height(height) {\n        this._height = height;\n\n        this.uniforms.size = [this._width, this._height];\n        this.__createOverlaySources();\n        this.__createCasterSources();\n        this.__createMaskSources();\n    }\n    get height() {\n        return this._height;\n    }\n    /**\n     * @type {boolean} Whether or not to use shadow casters as shadow overlays as well\n     */\n    set useShadowCasterAsOverlay(val) {\n        this._useShadowCastersAsOverlay = val;\n    }\n\n    get useShadowCasterAsOverlay() {\n        return this._useShadowCastersAsOverlay;\n    }\n}\n","import '@pixi/ticker';\n\nimport { Application } from '@pixi/app';\nimport { ShadowFilter } from '../filters/ShadowFilter';\nimport { Stage } from '@pixi/layers';\n\nexport function augmentApplication(application: Application, shadowFilter: ShadowFilter) {\n    // Replace the stage with a layered stage\n    application.stage = new Stage();\n\n    // Remove the current render function\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    application.ticker.remove(application.render, application);\n\n    // Overwrite the render function\n    application.render = function render(this: Application) {\n        // Update stage transforms\n        const cacheParent = this.stage.parent;\n        // this.stage.parent = this.renderer._tempDisplayObjectParent;\n        // this.stage.parent = this.stage._tempDisplayObjectParent;\n\n        this.stage.parent = this.stage;\n        this.stage.updateTransform();\n        this.stage.parent = cacheParent;\n\n        // Update the shadow filter\n        shadowFilter.update(this.renderer);\n\n        // Render the stage without updating the transforms again\n        this.renderer.render(this.stage, { skipUpdateTransform: true });\n    };\n\n    // Reassign ticker because its setter initialises the render method\n    // eslint-disable-next-line no-self-assign\n    application.ticker = application.ticker;\n}\n","import '@pixi/ticker';\n\nimport { Container } from '@pixi/display';\nimport { Group } from '@pixi/layers';\nimport { Shadow } from '../Shadow';\nimport { ShadowFilter } from '../filters/ShadowFilter';\n\nexport function augmentContainer(shadowCasterGroup: Group, shadowOverlayGroup: Group, shadowFilter: ShadowFilter) {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const orTransform: Container['updateTransform'] = Container.prototype.updateTransform;\n    const ticks = new WeakMap<Container, number>();\n\n    Container.prototype.updateTransform = function updateTransform(this: Container, ...args) {\n        if (this.parentGroup === shadowCasterGroup) {\n            if (ticks.get(this) !== shadowFilter.tick) shadowFilter._shadowCasterContainer.children.push(this);\n            ticks.set(this, shadowFilter.tick);\n        }\n\n        if (this.parentGroup === shadowOverlayGroup) {\n            if (ticks.get(this) !== shadowFilter.tick) shadowFilter._shadowOverlayContainer.children.push(this);\n            ticks.set(this, shadowFilter.tick);\n        }\n\n        if (this instanceof Shadow) {\n            if (ticks.get(this) !== shadowFilter.tick) shadowFilter._maskContainer.children.push(this);\n            ticks.set(this, shadowFilter.tick);\n        }\n\n        return orTransform.apply(this, args) as ReturnType<Container['updateTransform']>;\n    };\n}\n","import { Application, IApplicationOptions, IApplicationPlugin } from '@pixi/app';\nimport { Group, Layer } from '@pixi/layers';\n\nimport { Container } from '@pixi/display';\nimport { ShadowFilter } from './filters/ShadowFilter';\nimport { Sprite } from '@pixi/sprite';\nimport { augmentApplication } from './mixins/Application';\nimport { augmentContainer } from './mixins/Container';\n\nexport { filterFuncs } from './filters/FilterFuncs';\nexport { ShadowFilter } from './filters/ShadowFilter';\nexport { ShadowMaskFilter } from './filters/ShadowMaskFilter';\nexport { augmentApplication } from './mixins/Application';\nexport { augmentContainer } from './mixins/Container';\nexport { Shadow } from './Shadow';\n\nexport interface ShadowsOptions {\n    pixiLights?: {\n        diffuseGroup: Group;\n        normalGroup: Group;\n        lightGroup: Group;\n    };\n}\nexport class Shadows {\n    // The objects that will cast shadows\n    casterGroup = new Group();\n    // The objects that will remain ontop of the shadows\n    overlayGroup = new Group();\n    filter: ShadowFilter;\n    container = new Container();\n    constructor(app: Application, options?: ShadowsOptions) {\n        // // Create the shadow filter\n        this.filter = new ShadowFilter(app.renderer.width, app.renderer.height);\n        // Set up the container mixin so that it tells the filter about the available shadows and objects\n        augmentContainer(this.casterGroup, this.overlayGroup, this.filter);\n        // Overwrite the application render method\n        augmentApplication(app, this.filter);\n        app.stage.addChild(this.container);\n\n        if (options?.pixiLights) {\n            // Set up pixi-light's layers\n            const diffuseLayer = new Layer(options.pixiLights.diffuseGroup);\n            const normalLayer = new Layer(options.pixiLights.normalGroup);\n            const lightLayer = new Layer(options.pixiLights.lightGroup);\n            const diffuseBlackSprite = new Sprite(diffuseLayer.getRenderTexture());\n\n            diffuseBlackSprite.tint = 0;\n            // Set up the lighting layers\n            app.stage.addChild(diffuseLayer, diffuseBlackSprite, normalLayer, lightLayer);\n            // Add the shadow filter to the diffuse layer\n            app.stage.filters = [this.filter];\n        } else {\n            this.container.filters = [this.filter];\n        }\n    }\n}\ndeclare module '@pixi/app' {\n    export interface Application {\n        shadows: Shadows;\n    }\n    export interface IApplicationOptions {\n        fov?: ShadowsOptions;\n    }\n}\n\nexport const AppLoaderPlugin: IApplicationPlugin = {\n    init(this: Application, options: IApplicationOptions): void {\n        this.shadows = new Shadows(this, options.fov);\n    },\n    destroy(this: Application): void {\n        delete this.shadows;\n    },\n};\n"],"names":["Filter","Matrix","Sprite","RenderTexture","SCALE_MODES","BLEND_MODES","Container","Stage","Group","Layer"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA,MAAA,WAAA,YAAA,CAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA,MAAA,kBAAA,GAAA,QAAA,CAAA;AACA;AACA,MAAA,eAAA,SAAAA,WAAA,CAAA;AACA,IAAA,MAAA,GAAA,CAAA,IAAA,CAAA,OAAA,GAAA,MAAA,CAAA;AACA,IAAA,OAAA,GAAA,CAAA,IAAA,CAAA,OAAA,GAAA,EAAA,CAAA;AACA,IAAA,OAAA,GAAA,CAAA,IAAA,CAAA,wBAAA,GAAA,IAAAC,WAAA,GAAA,CAAA;AACA;AACA,IAAA,WAAA,EAAA,MAAA,EAAA;AACA,QAAA,KAAA;AACA,sBAAA,CAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAA,CAAA;AACA,sBAAA,CAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAA,EAAA,WAAA,CAAA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAA,EAAA,kBAAA,CAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAAA,EAAA,kBAAA,CAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAA,CAAA;AACA,SAAA,CAAA,IAAA,CAAA,MAAA,GAAA,MAAA,CAAA,eAAA,CAAA,SAAA,CAAA,MAAA,CAAA,IAAA,CAAA,IAAA,CAAA,CAAA,eAAA,CAAA,SAAA,CAAA,OAAA,CAAA,IAAA,CAAA,IAAA,CAAA,CAAA,eAAA,CAAA,SAAA,C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"}